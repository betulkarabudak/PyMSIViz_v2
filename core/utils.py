import numpy as npimport mathfrom bisect import bisect_left, bisect_rightfrom pyimzml.ImzMLParser import ImzMLParser# --------------------------- Utility ---------------------------def bisect_spectrum(mzs, mz_value, tol):    ix_l = bisect_left(mzs, mz_value - tol)    ix_u = bisect_right(mzs, mz_value + tol) - 1    if ix_l == len(mzs):        return len(mzs), len(mzs)    if ix_u < 1:        return 0, 0    if ix_u == len(mzs):        ix_u -= 1    if mzs[ix_l] < (mz_value - tol):        ix_l += 1    if mzs[ix_u] > (mz_value + tol):        ix_u -= 1    return ix_l, ix_udef getionimage(    p,    mz_value,    tol,    z,    reduce_func=sum,    *,    cancel_cb=None,    progress_cb=None):    tol = abs(float(tol))    mz_value = float(mz_value)    z = int(z)    im = np.zeros(        (p.imzmldict["max count of pixels y"],         p.imzmldict["max count of pixels x"]),        dtype=float    )    coords = p.coordinates    total = len(coords)    step = max(1, total // 100)    for i, (x, y, z_) in enumerate(coords):        if cancel_cb and cancel_cb():            return None        if z_ == z:            mzs, ints = map(np.asarray, p.getspectrum(i))            min_i, max_i = bisect_spectrum(mzs, mz_value, tol)            if max_i >= min_i:                im[y-1, x-1] = reduce_func(ints[min_i:max_i+1])        if progress_cb and (i % step == 0):            progress_cb(int((i / total) * 100))    if progress_cb:        progress_cb(100)    return imdef crop_zero_rows_cols(image):    """    Crop all-zero rows/cols but also return mapping indices (for ROI back-mapping).    Returns: cropped, row_idx, col_idx    """    if image.size == 0:        return image, np.array([], dtype=int), np.array([], dtype=int)    row_mask = ~(image == 0).all(axis=1)    col_mask = ~(image == 0).all(axis=0)    row_idx = np.where(row_mask)[0]    col_idx = np.where(col_mask)[0]    if row_idx.size == 0 or col_idx.size == 0:        return image, np.arange(image.shape[0]), np.arange(image.shape[1])    cropped = image[np.ix_(row_idx, col_idx)]    return cropped, row_idx, col_idxdef validate_numeric_input(value_str, param_name, allow_zero=False):    try:        value = float(value_str)        if not allow_zero and value <= 0:            raise ValueError(f"{param_name} must be positive")        return value    except Exception:        raise ValueError(f"Invalid {param_name}: {value_str}")