import numpy as npfrom scipy.signal import savgol_filter, find_peaksfrom scipy.stats import mannwhitneyufrom core.analytics import benjamini_hochberg# ============================================================# Global spectrum for volcano feature selection# ============================================================def build_global_spectrum_for_features(    parser,    max_pixels=1500,    n_bins=6000):    """    Build a global mean spectrum used ONLY for feature selection.    """    n = len(parser.coordinates)    if n == 0:        raise ValueError("No pixels found.")    idxs = (        np.arange(n)        if n <= max_pixels        else np.random.choice(n, max_pixels, replace=False)    )    mzs_list, int_list = [], []    for idx in idxs:        mzs, ints = parser.getspectrum(int(idx))        if mzs is not None and len(mzs) > 0:            mzs_list.append(np.asarray(mzs))            int_list.append(np.asarray(ints))    if not mzs_list:        raise ValueError("No valid spectra found in dataset.")    lengths = [len(m) for m in mzs_list]    # fast path: identical grids    if len(set(lengths)) == 1:        mz = np.mean(np.vstack(mzs_list), axis=0)        inten = np.mean(np.vstack(int_list), axis=0)        return mz.astype(float), inten.astype(float)    # fallback: bin to common grid    all_mz = np.concatenate(mzs_list)    all_int = np.concatenate(int_list)    bins = np.linspace(all_mz.min(), all_mz.max(), n_bins + 1)    dig = np.digitize(all_mz, bins)    mz, inten = [], []    for i in range(1, len(bins)):        m = (dig == i)        if m.any():            mz.append(bins[i])            inten.append(all_int[m].mean())    mz = np.asarray(mz, dtype=float)    inten = np.asarray(inten, dtype=float)    if mz.size == 0:        raise ValueError("Empty global spectrum.")    return mz, inten# ============================================================# Volcano feature selection# ============================================================def select_volcano_features(    mz,    inten,    max_features=800,        # ‚¨ÖÔ∏è arttƒ±rƒ±ldƒ±    min_dist_mz=0.05         # ‚¨ÖÔ∏è gev≈üetildi):    order = np.argsort(mz)    mz = mz[order]    inten = inten[order]    if inten.size >= 7:        w = min(31, inten.size if inten.size % 2 == 1 else inten.size - 1)        w = max(7, w)        inten = savgol_filter(inten, w, 3, mode="interp")    inten = np.maximum(inten, 0)    # ‚ùå flat spectrum exception KALDIRILDI    if np.all(inten <= 0):        return mz[:min(max_features, mz.size)]    mz_step = np.median(np.diff(mz)) if mz.size > 2 else 1.0    min_dist_idx = max(1, int(round(min_dist_mz / max(mz_step, 1e-12))))    height_thr = np.percentile(inten, 75)   # ‚¨ÖÔ∏è 90 ‚Üí 75    peaks, props = find_peaks(inten, distance=min_dist_idx, height=height_thr)    if peaks.size == 0:        return mz[:min(max_features, mz.size)]    heights = props["peak_heights"]    topk = np.argsort(heights)[-min(max_features, peaks.size):]    return np.sort(mz[peaks[topk]])# ============================================================# Per-feature volcano statistics# ============================================================def volcano_stat(vA, vB, eps=1e-12):    """    Compute log2 fold-change and p-value for one m/z feature.    """    vA = vA[vA != 0]    vB = vB[vB != 0]    # üîß slightly relaxed but still safe    if vA.size < 5 or vB.size < 5:        return None    mA = np.mean(vA)    mB = np.mean(vB)    log2fc = np.log2((mA + eps) / (mB + eps))    _, p = mannwhitneyu(vA, vB, alternative="two-sided")    return float(log2fc), float(p)# ============================================================# Final volcano statistics (UI-safe)# ============================================================def compute_volcano_statistics(    feature_mz,    values_A,    values_B,    alpha=0.1):    log2fc, pvals, feats = [], [], []    for mz, vA, vB in zip(feature_mz, values_A, values_B):        out = volcano_stat(vA, vB)        if out is None:            continue        fc, p = out        log2fc.append(fc)        pvals.append(p)        feats.append(mz)    # üî• ESKƒ∞ TARZ: 1 FEATURE Bƒ∞LE OLSA √áƒ∞Z    if len(pvals) == 0:        return {            "log2fc": np.array([0.0]),            "pvals": np.array([1.0]),            "y": np.array([0.0]),            "features": np.array([0.0]),            "rejected": np.array([False]),            "fdr_p": np.array([1.0])        }    log2fc = np.asarray(log2fc)    pvals = np.asarray(pvals)    feats = np.asarray(feats)    y = -np.log10(np.clip(pvals, 1e-300, 1.0))    try:        rejected, fdr_p = benjamini_hochberg(pvals, alpha)    except Exception:        rejected = np.zeros_like(pvals, dtype=bool)        fdr_p = pvals.copy()    return {        "log2fc": log2fc,        "pvals": pvals,        "y": y,        "features": feats,        "rejected": rejected,        "fdr_p": fdr_p    }